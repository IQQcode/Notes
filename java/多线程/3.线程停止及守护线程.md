@[TOC](线程停止)

**多线程中有三种方式可以停止线程:**

 * **设置标记位，可以是线程正常退出**

 * **使用stop方法强制使线程退出，但是该方法不太安全所以已经被废弃了**

 * **使用Thread类中的一个interrupt() 可以中断线程**

  

#### 一、设置标志位(无法处理线程阻塞时的问题)

#### 二、调用Thread类提供的stop方法强行关闭线程

为什么说不安全呢？

因为stop会解除由线程获取的所有锁定，当在一个线程对象上调用stop()方法时，这个线程对象所运行的线程就会**立即停止**。假如一个线程正在执行：`synchronized void { x = 3; y = 4;} `由于方法是同步的，多个线程访问时总能保证x,y被同时赋值，而如果一个线程正在执行到x = 3;时，被调用了 stop()方法，即使在同步块中，它也会马上stop了，这样就产生了不完整的残缺数据。

#### 三、调用Thread类提供的`interrupt()`

- 若线程中没有使用类似`sleep/wait/join()`时(使线程进入阻塞态)，调用此线程对象的==interrupt()==不会真正中断线程，只是简单的将线程的状态置为==interrupt()==而已，根据此状态来进一步确定如何处理线程

  

>Thread类提供的`isInterrupted()`可以检验当前线程状态是否为中断



- 若线程中调用了阻塞线程的方法`sleep\wait\join()`，此时再掉用线程的==interrupt()==时会抛出异常，同时线程状态还原(isInterrupted = false)

#### 四、线程的优先级

> 线程的优先级指的是优先级越高越==有可能==被先执行

**设置优先级**  `setPriority(int priority)`

**取得优先级**  `int getPriority`

JDK内置的三种优先级：

MAX_PRIORITYT = 10;

NORM_PRIORITYT = 5;

MIN_PRIORITYT = 1;

**线程的继承性：**

在一个线程中创建了子线程，默认子线程与父线程的优先级相同

#### 五、守护线程(DaemonThread)

java中线程分为俩类：用户线程、守护线程

**守护线程为陪伴线程**，只要JVM中存在任何一个用户线程没有终止，守护线程就一直在工作

默认创建的线程都是用户线程，包括主线程

通过`setDaemon(true)`将线程对象设置为守护线程

**典型的守护线程：垃圾回收线程**