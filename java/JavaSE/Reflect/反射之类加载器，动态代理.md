## ClassLoader 类加载器

### 1.  定义：

**类加载：**通过一个类的全名称来获取此类的二进制文件字节流

**类加载器：**实现类加载功能的代码模块

------



![1563593470134](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1563593470134.png)

### 2. JDK内置的三大类加载器

####  BootStrap （启动类加载器）

1. 使用C++语言实现，是JVM自身的一部分,独立于JVM外部，并且无法被Java程序直接使用

2. 负责将存放于**JAVA_HOME\lib**目录下==能被 JVM 识别==的所有类库(rt.jar---java基础类库[Object类，Data类])加载到 JVM中

   >**jar文件：**java的压缩文件，存放编译好的class文件

####  ExtClassLoader(拓展类加载器)

1. 使用Java语言实现，可以被Java程序直接引用
2. 负责将存放于 **JAVA_HOME\lib\ext** (xml文件解析类，Swing界面框架类) 目录下的所有能被 JVM 识别的类库

####  AppClassloader（应用程序类加载器）

1. 使用Java语言实现，如果用户没有实现自定义类加载器，则APPClassLoader就是程序中默认的类加载器
2. 负责加载用户**classpath**指定的类库



### 3. 类加载器的双亲委派模型

**定义：**四种类加载器的层次模型称为==类加载器的双亲委派模型==

![1563595225153](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1563595225153.png)



**工作流程：**

如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此。==因此，所有的加载请求都应当传送到顶层的`BootStrap`加载器中，只有当父加载器反馈无法完成这个加载请求时(在自己搜索范围中没有找到此类)，子加载器才会尝试自己去加载。==

**存在意义：**

==双亲委派模型对于保障Java程序的稳定运行十分重要==

>例如：
>
>**java.lang.Object** ，它存放在**rt.jar** 中，由于双亲委派模型的存在，无论哪一类类加载器加载此类，最终都是委派给处于顶端的启动类加载器进行加载。因此，Object类在程序的各种类加载器环境中都是同一个类

> **比较两个类是否相等的前提条件：**
>
> 这俩个类是由同一个类加载器加载的，只要加载这俩个类的类加载器不通，则这俩个类不相同...



### 4. 反射与动态代理



