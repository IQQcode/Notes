![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200724172145.png)

## 1. 垃圾回收概述

关于垃圾收集有三个经典问题：

1. 哪些内存需要回收？

2. 什么时候回收？

3. 如何回收？

这三个问题，也是贯穿JVM垃圾回收学习的路线。

### 什么是垃圾

垃圾是指：在运行的程序中**没有被任何指针指向的对象**，这个对象就是要被回收的垃圾。

如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能导致内存溢出。

### 为什么需要GC

- 不进行垃圾回收，内存不断的被分配而不回收，会导致内存被耗尽

- 垃圾回收也可以清除内存里的碎片，以便JVM将整理出的内存分配给新的对象

- 没有GC就不能保证应用程序的正常执行

> 👉[****Oracle-HotSpot虚拟机垃圾收集调优指南****](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)

### 对象是否存活

在GC执行垃圾回收前，首先需要区分内存中哪些是存活对象，哪些是已经死亡的对象。**当一个对象不再被任何存活的对象所引用时，就宣判此对象已死！垃圾对象就是已经死亡的对象**

垃圾回收的过程分为：

- 垃圾标记阶段，判断对象是否存活

- 垃圾清除阶段，清除被标记为垃圾（死亡）的对象

--------------------------



## 2. 标记阶段—引用计数算法

判断对象是否存活有两种方式：

1. **引用计数算法**

2. **可达性分析算法**

**引用计数算法**：对每个独享保存一个整型的应用计数器属性，用于记录对象呗引用的情况。

对于一个对象A：

- 只要有任何一个对象引用了A，则A的引用计数器加1

- 引用失效时，引用计数器减1

- 对象A的引用计数器值为0时，表示对象A没有被使用，标记为垃圾进行回收

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724181950.png)

**【优点】**

- 实现简单，垃圾对象便于标识

- 判定效率高，回收没有延迟性

**【缺点】**

- 需要单独的字段存储计数器，增加内存空间的开销（影响很小，就是一个变量）

- 需要更新计数器的值，增加时间开销

- <font color = red >致命缺陷：无法解决循环引用的问题。</font>这也是导致Java的垃圾回收器没有采用此算法的原因

**循环引用：**

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724182603.png)

`a`指向了`next1`，`next1`又被`next3`指向，所以`rc=2`

- 可以理解为循环链表，`a`为链表头结点，链表成环，循环引用指向

`a`断开了指向`next1`的指向，`next1`的`rc` 减一。源头的指向断开，则后面的应用没有了源头的指向后，就没法找到引用来被使用了，此时应该被标记为垃圾，即`rc=1`。

但是，由于存在`next3`的循环指向，`next1`任然有被指向，`rc`并不等于0，可能会导致内存泄漏。这就是引用计数算法无法解决循环引用的原因。

- 链表的头结点被删除了，则其后面的节点虽然还连接着，但是无法被使用了。应该被标记为垃圾进行回收

> 内存泄漏：对象已不再被使用，应该被回收，但是由于有引用的存在却无法被回收，最终导致内存占满而泄漏



Java并没有选择引用计数算法，是因为其存在一个基本的难题，也就是很难处理循环引用关系。

Python采用的是引用计数算法。Python如何解决循环引用的呢？

1. 手动解除：很好理解，就是在合适的时机，解除引用关系

2. 使用弱引用 weakref，weakref是 Python提供的标准库，旨在解决循环引用



---------------------



## 3. 标记阶段—可达性分析算法

可达性分析算法（根搜索算法、追踪性垃圾收集），可以有效的解决引用计数算法中循环引用的问题，房子内存泄漏的发生。是Java和C#所选择的。



所谓 "GC Roots" 根集合就是一组必须活跃的引用。

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724192846.png)

由GC Roots根集合直接或间接相连的对象，称为**可达**。`Object5`虽然有引用指向，但是GC Roots不可达，仍然标记为垃圾对象。



**【基本思路】**

- 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式**搜索被根对象集合所连接的目标对象是否可达**

- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<mark>引用链</mark>（ Reference chain）

- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。

- 在可达性分析算法中，只有能够被根对象集合**直接或者间接连接的对象**才是存活对象



### GC Roots

在Java中，GC Roots包括以下几类：

**1. 虚拟机栈中引用的对象**

- 局部变量表中的内容，包括方法参数、局部变量

**2. 类的静态属性**

- 引用类型的静态变量，JDK8及之后存储在堆上

**3. 方法区中的字符串常量池**

- String Table中的引用

**4. 被synchronized所持有的对象**

**5. 常驻的异常类对象（空指针、OOM）、系统类加载器**



【小结】

由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆上，则它就是一个Root。



------------------------



## 4. 对象的finalize机制

**对象的finalize机制**：对象被销毁之前的自定义逻辑处理（这个对象能否自我挽救）

由于每一个对象都可能会被垃圾回收器回收，所以每个对象皆具有此机制，那么它是公共类的方法，定义在Object类中的`finalize()`方法

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724200231.png)

- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的`finalize()`方法

- `finalize()`方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等

**Q & A：对象的finalize机制到底是干嘛的？**

- 就是给临死前的对象一个自我拯救的机会，将死之对象调用`finalize()`能否自救

### 生存？还是死亡

`finalize()`方法源码：

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724204210.png)



**永远不要主动调用**某个对象的`finalize()`方法，应该交给垃圾回收机制调用。

理由包括下面三点：

1. 在`finalize()`时可能会导致对象复活

2. `finalize()`方法的执行时间是没有保障的，它完由GC线程所决定。若不发生GC，则 `finalize()`方法将没有机会执行。

3. 一个糟糕的机会会严重影响GC的性能（如果覆写的finalize产生了死循环）


如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于**死缓阶段**。

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724205205.png)

一个无法触及的对象有可能在某一个条件下**复活自己**，如果这样，那么对它的回收就是不合理的。

> **复活**指的是对象又有引用被指向了，GC Roots可达

由于`finalize()`方法的存在，<font color = red>虚拟机中的对象一般处于三种可能的状态：</font>

- **可触及的**。从根节点开始，对象可达

- **可复活的**。对象无引用被指向，但仍可能在调用了`finalize()`后复活

- **不可触及的**。调用了`finalize()`后，自救失败！

【注意】：

<font color = blue>对象的`finalize()`只会被调用一次</font>，自救失败后就变成了垃圾对象进而被回收。



----------------------------------

## 5. 垃圾清除阶段

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。

目前在JVM中比较常见的三种垃圾收集算法是:

- 标记一清除算法Mark Sweep

- 复制算法Copying、

- 标记一压缩算法Mark Compact

### STW

Java中 Stop-The-World 机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集器之外）。

STW是Java中一种**全局暂停现象**，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。



**GC时为什么会有全局停顿？**

类比在聚会时打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。

当GC线程在处理垃圾的时候，其它Java线程要停止才能彻底清除干净，否则会影响GC线程的处理效率增加GC线程负担，特别是在垃圾标记的时候。

-----------------

## 6. 清除阶段：标记—清除算法

当堆空间中有效的内存空间被耗尽时，JVM会停止整个程序，即STW。然后进行两项工作：

- 标记

- 清除

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724214640.png)

**【核心思想】**

**标记：** Collector从引用GC Roots开始**递归遍历**，标记所有 <font color = red>**被引用的可达对象**</font>

**清除：** Collector对堆内存**从头到尾进行线性遍历**，如果发现某个对象在Header中没有标记为可达，则将其回收

> 为什么标记的是可达的对象？
> 
> - 因为不可达的对象可能不连续，无法关联。标记了可达的对象之后，通过线性遍历清除*未被标记*的“不可达对象”

**Q & A：何为清除？**

这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就**覆盖存放**。

**清除指的是覆盖。**

> 🖥这一点可以类比我们的操作系统的文件删除。我们把文件误删了，但是还是能通过文件恢复工具将其恢复。我们并不是真正意义上的“删除”，只是将存储的文件的引用指向的指针删除了，真实的文件还在📖。等到再次在这块地址上存放文件时，将原有的覆盖。



**【缺点】**

- 效率不算高

- 在进行GC时，会有STW，用户线程体验差

- 可能产生内存的碎片化，需要维护**空闲列表**

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724215513.png)



对象分配内存的策略：

- 如果内存完整🌕——指针碰撞

- 如果内存不完整🌛——空闲列表

显然，通过标记—清除算法回收的碎片化的内存，只能通过空闲列表来为对象分配内存。如果要分配大对象时，可能无法对象的创建和初始化。

-------------------------



## 7. 清除阶段：复制算法

为了解决标记—清除算法在垃圾回收效率方面的缺陷。

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/imgs01/20200724222237.png)

**【核心思想】**

- 将内存空间划分为两大块，每次只使用其中一块

- 将存活的可达对象**复制**（深拷贝）到未被使用的内存块，并且清理正在使用的内存块中的<font color = red>**所有对象**</font>

- 交换两个内存块的角色，完成垃圾回收

复制到另一块内存时，可达对象是紧密排列的。

连续的内存空间，在对象创建分配内存时，是通过**指针碰撞**的方式进行的。



**【优点】**



**【缺点】**



---------------------



## 8. 清除阶段：标记—整理算法





---------------------------------------



## 9. 三种算法的对比即应用



------------------



## 10. 复合算法：分代收集算法



------------------------------



## 11. 复合算法：增量收集算法



--------------------------------



## 12. 复合算法：分区算法




