{"files":{"1.JVM内存区域与内存溢出异常.md":{"mtime":1592825419452.145,"size":6004,"hash":"e5e30176ad26f01d68518d435190e61db39ba373dad2003eeb1773131c229f55"},"2.JVM垃圾回收器与内存分配策略.md":{"mtime":1569057453539.75,"size":9645,"hash":"5577691b1e1813dc20353ef4957740aa62d866da0f86e1b3e6bbdcf193b53fd4"},"3.JVM内存与垃圾回收.md":{"mtime":1591106231858.568,"size":0,"hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},"4.JVM字节码与类加载.md":{"mtime":1591106257303.6477,"size":0,"hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},"5.JVM性能监控与调优.md":{"mtime":1591106281975.5613,"size":0,"hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},"6.Java内存模型JMM详解.md":{"mtime":1592044175984.382,"size":27528,"hash":"0fb3ba3767a76d621c1f2aedfd0dea6d43d158aaf2a072bc13780e9bc3def4f1"},"a-类加载系统/类加载系统.md":{"mtime":1594650592150.0354,"size":8008,"hash":"d940accab3e1ab9a2358c8ae55450c5aad2c536437fc7fad30cccd94468c7935"},"b-运行时数据区/02.运行时数据区及线程.md":{"mtime":1594732129467.8345,"size":1103,"hash":"bb36c03b877757c9a54e4a733f5ecce1e1bcbba48e7d39383324c6b428410753"},"b-运行时数据区/03.程序计数器.md":{"mtime":1593100299609.5168,"size":3853,"hash":"a6f1b1e500366d890f42a5fd6af92e88ef308bd96b3015f85db80a1d5d3f6881"},"b-运行时数据区/04.虚拟机栈.md":{"mtime":1595256230674.6636,"size":13821,"hash":"d396de2d8cc67ed162f8f941b8efc7ced0742bae96d7af1fb7eab850d55cb36e"},"b-运行时数据区/05.本地方法栈.md":{"mtime":1593789256399.8813,"size":1982,"hash":"9e0e9a5061f8eecc5d401e3794ab7ba6e0431c7820aa3b4e4f275a84e6f87be1"},"b-运行时数据区/06.堆.md":{"mtime":1593790913883.912,"size":14373,"hash":"e6d3528270f5a8f6c83859187aa1d917ebf800fa726cfed78ad9f7e80e1da6d8"},"b-运行时数据区/07.方法区.md":{"mtime":1594974054530.0664,"size":14095,"hash":"f68e21af164ee06649974b680f25df1bff42b1d8fa5addab225d7090d2de2b8d"},"b-运行时数据区/08.对象实例化的内存布局与访问定位.md":{"mtime":1594021743113.069,"size":520,"hash":"6bc1a305e494ddd8ca8dc0aa7fd8b0e4927910e065e79f17f1c31cafcc551447"},"b-运行时数据区/09.直接内存.md":{"mtime":1592881534564.3606,"size":0,"hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},"b-运行时数据区/站在虚拟机栈的角度，用字节码来理解i++和++i.md":{"mtime":1593178778559.6902,"size":11134,"hash":"cd1ebef04c97f8e8251fb42374da685d9696cc71ad030dce59ca8d49cb5eaf70"},"b-运行时数据区/面试考点.md":{"mtime":1594017750331.3254,"size":1365,"hash":"b1f997bfaec4594d499735c73e1245c1f1b681fa6aada70534820a85d33707d5"},"c-执行引擎/09.执行引擎.md":{"mtime":1595166557537.153,"size":6474,"hash":"8039e6dfdd74f69af457981ba2029232462151c91680d6e4dd58cfcc61eadfa5"},"c-执行引擎/10.垃圾回收算法.md":{"mtime":1595167466453.076,"size":0,"hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},"c-执行引擎/11.垃圾回收器.md":{"mtime":1592881534564.3606,"size":0,"hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},"c-执行引擎/StringTable详解.md":{"mtime":1594564030063.8335,"size":14341,"hash":"1385c28a8d4ef7c3e6c84772091beaf7631ea0d7475838b3078220aee7704e4a"},"outline.png":{"mtime":1592886862277.9497,"size":340637,"hash":"7af7e1c1111db93011fba4a8ad3c037fcb13d17c4a99325587c1311e0d85dda0"}},"metadata":{"e5e30176ad26f01d68518d435190e61db39ba373dad2003eeb1773131c229f55":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"1. JVM简介","level":3},{"line":18,"heading":"2. JVM内存区域划分","level":3},{"line":24,"heading":"线程私有内存","level":4},{"line":38,"heading":"I. 程序计数器 :","level":5},{"line":57,"heading":"II. 虚拟机栈 ：","level":5},{"line":84,"heading":"III. 本地方法栈","level":5},{"line":90,"heading":"线程共享内存","level":4},{"line":94,"heading":"I. Java堆","level":5},{"line":106,"heading":"II. 方法区","level":5},{"line":111,"heading":"III. 运行时常量池","level":5}]},"5577691b1e1813dc20353ef4957740aa62d866da0f86e1b3e6bbdcf193b53fd4":{"links":[],"embeds":[],"tags":[],"headings":[{"line":8,"heading":"1. 垃圾回收策略","level":3},{"line":45,"heading":"2. 引用的扩充","level":3},{"line":108,"heading":"3. 对象的自我拯救","level":3},{"line":178,"heading":"4. 方法区的回收","level":3},{"line":184,"heading":"5. 垃圾回收算法(堆上)","level":3},{"line":186,"heading":"I. 标记清除算法","level":4},{"line":203,"heading":"II. 复制算法(新生代回收算法)","level":4},{"line":235,"heading":"III. 标记-整理算法(老年代回收算法)","level":4},{"line":245,"heading":"IV. 分代收集策略(JavaGC)","level":4}]},"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855":{"links":[],"embeds":[],"tags":[],"headings":[]},"0fb3ba3767a76d621c1f2aedfd0dea6d43d158aaf2a072bc13780e9bc3def4f1":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"【引言】","level":2},{"line":26,"heading":"1. 多核并发缓存架构","level":2},{"line":30,"heading":"CPU缓存","level":3},{"line":58,"heading":"JMM内存模型简介","level":3},{"line":82,"heading":"2. JMM内存模型验证","level":2},{"line":84,"heading":"volatile验证内存模型","level":3},{"line":162,"heading":"JMM内存模型8大原子操作","level":3},{"line":220,"heading":"3. JMM缓存不一致问题","level":2},{"line":228,"heading":"总线加锁","level":3},{"line":238,"heading":"MESI缓存一致性协议","level":3},{"line":260,"heading":"4. volatile可见性底层实现原理","level":2},{"line":274,"heading":"保证可见性原理验证","level":3},{"line":319,"heading":"5. volatile不保证原子性","level":2},{"line":321,"heading":"不保证原子性验证","level":3},{"line":386,"heading":"【问题解决】","level":3},{"line":402,"heading":"6. volatile保证有序性","level":2},{"line":406,"heading":"volatile禁止指令重排序","level":3},{"line":482,"heading":"内存屏障简介","level":3},{"line":524,"heading":"JMM的Happens-Before原则","level":3}]},"d940accab3e1ab9a2358c8ae55450c5aad2c536437fc7fad30cccd94468c7935":{"links":[],"embeds":[],"tags":[],"headings":[{"line":2,"heading":"1. Java内存结构概述","level":2},{"line":20,"heading":"2. 类加载过程","level":2},{"line":32,"heading":"加载Loading","level":3},{"line":48,"heading":"链接Linking","level":3},{"line":84,"heading":"初始化Initialization","level":3},{"line":92,"heading":"3. 类加器的分类","level":2},{"line":159,"heading":"4. 双亲委派模型","level":2},{"line":244,"heading":"5. Class对象是否相等","level":2}]},"bb36c03b877757c9a54e4a733f5ecce1e1bcbba48e7d39383324c6b428410753":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"1. 运行时数据区","level":2},{"line":8,"heading":"运行时数据区内存划分","level":3}]},"a6f1b1e500366d890f42a5fd6af92e88ef308bd96b3015f85db80a1d5d3f6881":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"1. 程序计数器","level":2},{"line":16,"heading":"线程私有","level":3},{"line":24,"heading":"不会产生OOM","level":3},{"line":30,"heading":"2. 程序计数器的使用","level":2},{"line":63,"heading":"3. 面试题考点","level":2}]},"d396de2d8cc67ed162f8f941b8efc7ced0742bae96d7af1fb7eab850d55cb36e":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"1. 虚拟机栈概述","level":2},{"line":4,"heading":"虚拟机栈出现背景","level":3},{"line":12,"heading":"内存中的栈与堆","level":3},{"line":22,"heading":"虚拟机栈的基本内容","level":3},{"line":36,"heading":"出现的异常","level":3},{"line":54,"heading":"2. 虚拟机栈的内部结构","level":2},{"line":56,"heading":"栈中存储什么","level":3},{"line":74,"heading":"栈帧的内部数据","level":3},{"line":94,"heading":"3. 局部变量表","level":2},{"line":223,"heading":"4. 操作数栈","level":2},{"line":344,"heading":"5. 动态链接","level":2},{"line":372,"heading":"6. 方法返回地址","level":2},{"line":390,"heading":"7. 附加信息","level":2}]},"9e0e9a5061f8eecc5d401e3794ab7ba6e0431c7820aa3b4e4f275a84e6f87be1":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"1. 什么是本地方法","level":2},{"line":14,"heading":"2. 为什么要使用本地方法","level":2},{"line":26,"heading":"3. 本地方法栈","level":2}]},"e6d3528270f5a8f6c83859187aa1d917ebf800fa726cfed78ad9f7e80e1da6d8":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"1. 堆Heap","level":2},{"line":12,"heading":"堆的核心-内存细分","level":3},{"line":38,"heading":"堆空间大小设置","level":3},{"line":58,"heading":"2. 新生代和老年代","level":2},{"line":72,"heading":"对象内存分配","level":3},{"line":134,"heading":"特殊情况讨论","level":3},{"line":164,"heading":"3. 代码调试分析说明","level":2},{"line":207,"heading":"分析说明","level":3},{"line":229,"heading":"4. Minor GC、Major GC、Full GC","level":2},{"line":253,"heading":"新生代Minor GC触发机制","level":3},{"line":265,"heading":"老年代Major GC/Full GC触发机制","level":3},{"line":279,"heading":"Full GC触发机制","level":3},{"line":295,"heading":"5. Java堆为什么要分代","level":2},{"line":311,"heading":"线程的TLAB","level":3},{"line":319,"heading":"一些说明","level":3}]},"f68e21af164ee06649974b680f25df1bff42b1d8fa5addab225d7090d2de2b8d":{"links":[],"embeds":[],"tags":[],"headings":[{"line":4,"heading":"1. 方法区","level":2},{"line":16,"heading":"方法区理解","level":3},{"line":42,"heading":"方法区的演进","level":3},{"line":80,"heading":"永久代为什么要被替换为元空间","level":3},{"line":98,"heading":"方法区的设置与OOM","level":3},{"line":110,"heading":"2. 方法区的内部结构","level":2},{"line":126,"heading":"类型信息","level":3},{"line":138,"heading":"域信息","level":3},{"line":146,"heading":"方法信息","level":3},{"line":162,"heading":"3. 运行时常量池","level":2},{"line":172,"heading":"运行时常量池vs常量池","level":3},{"line":220,"heading":"4. 代码追踪方法区的使用","level":2}]},"6bc1a305e494ddd8ca8dc0aa7fd8b0e4927910e065e79f17f1c31cafcc551447":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"1. 对象的实例化","level":2},{"line":23,"heading":"2. 对象的内存布局","level":2}]},"cd1ebef04c97f8e8251fb42374da685d9696cc71ad030dce59ca8d49cb5eaf70":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"面试官的拷问","level":3},{"line":28,"heading":"暖场准备","level":3},{"line":62,"heading":"开始表演","level":3},{"line":202,"heading":"拓展","level":3}]},"b1f997bfaec4594d499735c73e1245c1f1b681fa6aada70534820a85d33707d5":{"links":[],"embeds":[],"tags":[],"headings":[{"line":6,"heading":"1. 你真的了解i++和++i吗？","level":4},{"line":8,"heading":"2. 举例栈溢出StackOverflowError的情况？","level":4},{"line":14,"heading":"3. 调整栈大小，就能保证不出现溢出吗？分配的栈内存越大越好吗？","level":4},{"line":20,"heading":"5. 垃圾回收是否会涉及到虚拟机栈?","level":4}]},"8039e6dfdd74f69af457981ba2029232462151c91680d6e4dd58cfcc61eadfa5":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"1. 执行引擎概述","level":2},{"line":16,"heading":"2. 执行引擎工作过程","level":2},{"line":28,"heading":"3. 前端编译器与后端编译器","level":2},{"line":36,"heading":"前端编译","level":3},{"line":58,"heading":"后端编译","level":3},{"line":86,"heading":"4. Java程序的编译与执行","level":2},{"line":102,"heading":"理解Java-半编译半解释型语言","level":3},{"line":134,"heading":"TODO","level":2}]},"1385c28a8d4ef7c3e6c84772091beaf7631ea0d7475838b3078220aee7704e4a":{"links":[],"embeds":[],"tags":[],"headings":[{"line":2,"heading":"1. String的基本特性","level":2},{"line":32,"heading":"String的不可变性","level":3},{"line":76,"heading":"2. String的内存分配","level":2},{"line":94,"heading":"3. 字符串的拼接","level":2},{"line":96,"heading":"字符串拼接细节说明","level":3},{"line":193,"heading":"面试题测试","level":3},{"line":228,"heading":"效率对比","level":3},{"line":245,"heading":"4. intern方法","level":2},{"line":275,"heading":"new String的讨论","level":3},{"line":375,"heading":"拓展","level":3},{"line":383,"heading":"intern总结","level":3}]},"7af7e1c1111db93011fba4a8ad3c037fcb13d17c4a99325587c1311e0d85dda0":{"links":[],"embeds":[],"tags":[],"headings":[]}},"algorithmVersion":9}