## 1. 虚拟机栈概述

### 虚拟机栈出现背景

由于跨平台性的设计，Java指令都是**基于栈**（8位对齐）来设计的。不同平台的CPU架构不同，所以不能设计为基于寄存器的（16位为对齐）。

【基于栈的优势】：跨平台，指令集小，编译器容易实现；

【劣势】：性能下降，实现的同样的功能指令多

### 内存中的栈与堆

<font color = red>**栈是运行时的单位，堆是存储时的单位。**</font>

- 虚拟机栈解决程序的运行问题，程序执行最终都是压入虚拟机栈的栈帧中

- 堆解决的是数据存储问题，（除去基本类型之外）主体数据均是存储在堆上

> 就好比是我们电脑的内存和硬盘，程序的执行都需要加载到内存中来运行。但是保存数据都是持久化在硬盘上的，硬盘中的数据需要读取到内存中才能执行。



### 虚拟机栈的基本内容

【作用】：管理Java程序的运行，保存方法的局部变量、部分结果，参与方法的调用和返回

【生命周期】：与线程的生命周期相同

【特点】

- 访问速度仅次于PC计数器（只涉及到入栈和出栈的操作）

- 不存在垃圾回收问题

> 会存在OOM和StackOverflow

### 出现的异常

Java虚拟机规范允许<font color = red>Java栈的大小是动态的或者固定不变的</font>

《Java虚拟机规范》中规定了两类异常状况：

- 如果线程请求的栈的深度大于虚拟机所允许的最大深度，抛出`StackOverflowError`

- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那JVM将会抛出`OutOfMemoryError`异常

> HotSpot虚拟机栈容量不可以动态扩展，但是申请失败是仍会产生OOM



【手动设置虚拟机栈的容量大小】

- `-Xss256k`（单位为k、m、g，忽略大小写）

----------------------------------------------------

## 2. 虚拟机栈的内部结构

### 栈中存储什么

虚拟机栈的基本单元是**栈帧**（Stack Frame），一个栈帧对应一个Java方法的调用

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200625150543.png)

【执行原理】

由于虚拟机栈是线程私有的，不同的线程有不同的栈，不同的栈之间数据不能共享。即不可能存在一个栈帧中引用另外一个线程的栈帧。它们可以通过同一个进程来共享数据。

**Java方法有两种返回函数的方式：** 

- 一种是正常的函数返回，使用 return指令；

- 另外一种是抛出异常。

> 不管使用哪种方式，都会导致栈帧被弹出

### 栈帧的内部数据

**每个栈帧中存储着5部分数据：**

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200625173710.png)

- 局部变量表（Local Variables）

- 操作数栈（Operaan Stack）

- 动态链接（Dynamic Linking）

- 方法返回地址（Return Address）

- 附加信息

接下来，我们分别讨论这5部分的作用

## 3. 局部变量表

局部变量表Local Variables（局部变量数组或者本地变量表）。

1. 局部变量表是一个<font color = pink>数字数组</font>，主要用于存储方法参数和定义在方法体内的局部变量。
   
    - 数据类型包括：基本数据类型、引用类型、返回值类型

2. 线程私有数据，不存在线程安全问题

3. 局部变量表的容量大小在<font color = pink>编译期间</font>被确定，在方法运行期间不会改变



使用 jclasslib插件查看out包下反编译后的字节码文件

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200625191813.png)

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200625192601.png)

main方法对应的字节码文件

```java
 0 new #1 <iqqcode/jvmstack/LocalVariablesTest01>
 3 dup
 4 invokespecial #2 <iqqcode/jvmstack/LocalVariablesTest01.<init>>
 7 astore_1
 8 bipush 10
10 istore_2
11 aload_1
12 invokevirtual #3 <iqqcode/jvmstack/LocalVariablesTest01.test1>
15 return
```

```java
package iqqcode.jvmstack;

import java.util.Date;

/**
 * @Author: Mr.Q
 * @Date: 2020-06-25 09:39
 * @Description:局部变量表容量测试
 */
public class LocalVariablesTest01 {
    private int count = 0;

    public static void main(String[] args) {
        LocalVariablesTest01 test = new LocalVariablesTest01();
        int num = 10;
        test.test1();
    }

    //练习：
    public static void testStatic(){
        LocalVariablesTest01 test = new LocalVariablesTest01();
        Date date = new Date();
        int count = 10;
        System.out.println(count);
        //因为this变量不存在于当前方法的局部变量表中！！
        //System.out.println(this.count);
    }

    //关于Slot的使用的理解
    public LocalVariablesTest01(){
        this.count = 1;
    }

    public void test1() {
        Date date = new Date();
        String name1 = "iqqcode";
        test2(date, name1);
        System.out.println(date + name1);
    }

    public String test2(Date dateP, String name2) {
        dateP = null;
        name2 = "Mr.Q";
        double weight = 130.5;//占据两个slot
        char gender = '男';
        return dateP + name2;
    }

    public void test3() {
        this.count++;
    }

    public void test4() {
        int a = 0;
        {
            int b = 0;
            b = a + 1;
        }
        //变量c使用之前已经销毁的变量b占据的slot的位置
        int c = a + 1;
    }

    public void test5Temp() {
        int num;
        //System.out.println(num);//错误信息：变量num未进行初始化
    }
}
```


 变量的分类：按照数据类型分：① 基本数据类型 ② 引用数据类型
 按照在类中声明的位置分：① 成员变量：在使用前，都经历过默认初始化赋值
 类变量： linking的prepare阶段：给类变量默认赋值 ---> initial阶段：给类变量显式赋值即静态代码块赋值
 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值
 ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过
 





## 4. 操作数栈



## 5. 动态链接



## 6. 方法返回地址



## 7. 附加信息
