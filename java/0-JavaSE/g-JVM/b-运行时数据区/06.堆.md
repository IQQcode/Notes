## 1. 堆Heap

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629175321.png)

一个进程对应一个JVM实例，一个JVM实例就对应一个运行时数据区Rutime Data Area（Runtime类是饿汉式单例）。一个进程对应多个线程，一个进程中的多个线程共享同一块堆空间，共享同一个方法区。

**在方法结束后，堆中的对象不会立刻被移除，仅仅在执行引擎垃圾回收的时候才会被移除。**

堆，是GC（ Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

### 堆的核心-内存细分

现代垃圾回收器大部分都是基于分代手机理论设计，堆空间细分为：

> 约定：
> 
> - 新生区==>新生代==>年轻代
> 
> - 养老区==>老年区==>老年代
> 
> - 永久区==>永久代

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629152823.png)

**JDK 7及之前：**

新生代 + 老年代 + <font color=green>永久代</font>

**JDK 8及之后：**

新生代+  老年代 + <font color=red>元空间</font>

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629161449.png)

**元空间、永久代是方法区具体的落地实现**



### 堆空间大小设置

堆用来存储Java对象实例，堆的大小在JVM启动时就已经设定好了。堆空间的大小可以通过两个参数来设置：（-X表示虚拟机参数）

- `-Xms`(memory start)：堆区起始内存

- `-Xmx`(memory max)：堆区最大内存

一旦堆区的内存超过`-Xmx`锁指定的最大内存时，会抛出**OutOfMemoryError**

通常会将`-Xms`和`-Xmx`两个参数配置相同的值，其目的是为了能够在GC后，不需要重新分隔计算堆区的大小，从而提高性能。

【默认情况下】

- 初始内存大小：物理内存的 1 /  64

- 最大内存大小：物理内存的 1 / 4

## 2. 新生代和老年代

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629173208.png)

其中新生代分为**Eden区、Suvivor 0区、Survivor 1区**（有时也叫From区、To区）

> 元空间、永久代是方法区具体的落地实现

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629173511.png)



### 对象内存分配

 
