## 1. 堆Heap

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629175321.png)

一个进程对应一个JVM实例，一个JVM实例就对应一个运行时数据区Rutime Data Area（Runtime类是饿汉式单例）。一个进程对应多个线程，一个进程中的多个线程共享同一块堆空间，共享同一个方法区。

**在方法结束后，堆中的对象不会立刻被移除，仅仅在执行引擎垃圾回收的时候才会被移除。**

堆，是GC（ Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

### 堆的核心-内存细分

现代垃圾回收器大部分都是基于分代手机理论设计，堆空间细分为：

> 约定：
> 
> - 新生区==>新生代==>年轻代
> 
> - 养老区==>老年区==>老年代
> 
> - 永久区==>永久代

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629152823.png)

**JDK 7及之前：**

新生代 + 老年代 + <font color=green>永久代</font>

**JDK 8及之后：**

新生代+  老年代 + <font color=red>元空间</font>

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629161449.png)

**元空间、永久代是方法区具体的落地实现**

### 堆空间大小设置

堆用来存储Java对象实例，堆的大小在JVM启动时就已经设定好了。堆空间的大小可以通过两个参数来设置：（-X表示虚拟机参数）

- `-Xms`(memory start)：堆区起始内存

- `-Xmx`(memory max)：堆区最大内存

一旦堆区的内存超过`-Xmx`锁指定的最大内存时，会抛出**OutOfMemoryError**

通常会将`-Xms`和`-Xmx`两个参数配置相同的值，其目的是为了能够在GC后，不需要重新分隔计算堆区的大小，从而提高性能。

【默认情况下】

- 初始内存大小：物理内存的 1 /  64

- 最大内存大小：物理内存的 1 / 4

--------------------------------

## 2. 新生代和老年代

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629173208.png)

其中新生代分为**Eden区、Suvivor 0区、Survivor 1区**（有时也叫From区、To区）

> 元空间、永久代是方法区具体的落地实现

**堆空间占比分配：**

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701174154.png)

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200629173511.png)

### 对象内存分配

一个对象被分配内存、到创建、再到到消亡，它经历了怎样的过程呢？我们通过这张图，来做具体说明：

【概念明确】：

- Eden - 伊甸园区

- Survivor - 幸存者区（Survivor0 - S0、Survivor1 - S1）

- 垃圾对象 - 不再使用的对象，即没有指向的对象

- 存活的对象 - 不是垃圾的对象（还被使用）

- Tenured/Old - 老年区

> Survivor0 - S0、Survivor1 - S1也称`from`区和`to`区。名称不是固定的，from是满的一个，to是空的一个。

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701160046.png)

> 假设首次Survivor0和Survivor1均为空

**1. 首先`new`参生的对象会放到Eden**

**2. 当Eden区空间满了时，程序又需要创建对象。YGC/Minor GC（可达性分析算法）对Eden区的垃圾对象进行回收，将存活的对象放入到Survivor0区。每个对象的年龄计数器`age` + 1**

**3. 此时Eden为空，存活的对象放入到了S0中**

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701164923.png)

**4. 继续在Eden区创建新对象，Eden区再次装满，触发Minor GC**

**5. 再次将剩余存活的对象放入到Survivor区。此时，S0已满，放入到S1中**

**6. 判断S0区中的对象还是否被使用，如不使用则回收，使用则放入到S1中。`age`计数器+1**

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701165132.png)

**7. 此时Eden和S0为空，存活的对象均在S1中**

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701170350.png)

> 此时S0称为to区，s1称为from区

**8. Eden区中再次创建对象直至满为止，存活的对象放入S0中，同时判断S1中是否有可回收答垃圾对象**

**9. 当Survivor区中有对象的对象计数器age达到阈值15时，将其从Survivor中晋升到Old区**

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701170713.png)

> 阈值设置参数：-XX:MaxTenuringThresho1d=<N>进行设置

-------------------

**【总结】：**

- 针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to

- 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。

- 80%左右的对象在新生代中就被销毁了，朝生夕死

### 特殊情况讨论

-----------------

![](https://iqqcode-blog.oss-cn-beijing.aliyuncs.com/img/20200701182422.png)

**Q1：Survivor区满了会触发YGC/Minor GC吗？**

- <font color = red>不会的。Survivor区满了不会触发YGC，但是它会被垃圾回收。</font>当每次堆Eden进行YGC时，会对Suevivor也进行判断回收。只不过区别于Eden，这个过程是被动的。

**Q2：当Survivor满了时怎么办？**

- 如果Eden回收完后，此时Survivor为满时，就将Eden中的存活对象直接放入到Old区中。即使`age`没有达到阈值，也有可能直接晋升到老年代（理解为跨级晋升）

**Q3：对象有可能一创建就放到老年代吗？**

- 有可能。在YGC之后，对于超大对象来说还是存放不下，直接放入到老年代。

**Q4：超大对象老年代也放不下怎么办？**

> 针对不动态调整内存空间机制的虚拟机

- 先对老年代进行**Major GC**，看是否能够存放，是则放入老年代

- **Major GC**完之后还是放不下，抛出<font color = red>OOM</font>

----------------------------------------------
