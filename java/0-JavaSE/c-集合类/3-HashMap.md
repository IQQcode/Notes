## 1. HashMap原理探究

HashMap底层的实现采用了哈希表，哈希表的实现：

- JDK 1.8之前：数组 + 单向链表

- JDK 1.8之后：数组 + 单向链表 / 红黑树（链表的长度超过8）

`Node<K,V>[] table`就是HashMap核心的数据结构，也称之为“位桶数组”。

HashMap集合是一个无序的集合，不保证映射的顺序，存储元素和取出元素的顺序有可能不一致。

HashMap内部节点

![](3-HashMap.assets/20200531090151.png)

一个节点类存储了：

- `hasn`：键对象的哈希值

- `key`：键

- `value`：值

- `next`：下一个节点的位置

每一个Node对象就是就是一个单链表结构

![](3-HashMap.assets/20200531091255.png)

然后，我们映射出`Node<K,V>[]`数组的结构（HashMap的结构）：

![](3-HashMap.assets/20200531093153.png)

其实就是在数组中存放一个链表。那数组中是怎么存放的链表呢？`hash`又怎么计算呢？

怎么能通过`key`来找到对应的`value`呢？

我们接着来探讨。

## 2. 存储数据

我们的目的是将`key-value`两个对象**成对**存放到 HashMap的Node数组中。**核心就是产生hash值，该值用来对应数组的存储位置**

```java
put(1,"test");
```

![](3-HashMap.assets/20200531101145.png)

**第一步：获取Key对象的hashCode**

调用key对象的`hashCode`方法，获得哈希码

> hashCode是Object类中的对象，所以任何类对象都可以调用

**第二步：计算hsah值**

根据hashCode计算出`hash`值（要求在 [0 ， 数组长度-1] 之间）

hashCode是一个整数，我们需要将它转化成 [0 ， 数组长度-1] 的范围。我们要求转化后的hash值尽量均匀地分布在 [0 ， 数组长度-1] 这个区间，减少**hash冲突**

> hash(哈希)冲突：不同的hashCode转换为hash值时计算出的结果相同

**【hash值的计算】**

I. 极端情况

```java
hash =  hashCode / hashCode;
```

hash值总是1。意味着，键值对对象都会存储到数组索引`1`位置，这样就形成一个非常长的链表。相当于每存储一个对象都会发生“hash冲突”， HashMap也退化成了一个“链表”。

![](3-HashMap.assets/20200531114308.png)

hash值都不相同，退化为长度为N的数组。此时hash成为了数组下标

![](3-HashMap.assets/20200531114706.png)

**所以，我们必须采用折中的算法，让数组的容量不能太大，让链表的长度不能太长。让存储在哈希表中的数据尽量散开均匀分布，提高查询速度。**

—种简单和常用的算法是**相除取余算法**

```java
hash值 = hashCode % 数组长度;
```

这种算法可以让hash值均匀的分布在 [0 ， 数组长度-1] 的区间。早期的Hashtable就是采用这种算法。但是，这种算法由于使用了“除法″，效率低下。

JDK后来改进了算法。首先约定数组长度必须为2的整数幂，这样采用位运算可实现取余的效果：

```java
hash值 = hashCode &(数组长度 - 1);
```

**第三步：生成Node对象**

一个Node对象包含4部分：key对象、 value对象、hash值、指向下一个Node对象的引用。

我们现在算出了hash值，下一个 Entry对象的引用为null

**第四步：将Node对象放到table数组中**

- 如果本Node对象对应的数组索引位置还没有放Node对象，则直接将Node对象存储进数组；

- 如果对应索引位置已经有Node对象，则将已有Node对象的next指向本Node对象，形成链表

**总结：**

当添加一个元素`key-value`时，首先计算`key`的hash值，以此确定插入数组中的位置。但是可能存在同hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，就形成了链表。

同一个链表上的hash值是相同的，所以说数组存放的是链表。

JDK8及之后，当链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率

![](3-HashMap.assets/20200524222943.png)

-----------------------

## 3.取出数据

```java
get(1); //test
```

我们需要通过key对象获得“键值对”对象，进而返回value对象。明白了存储数据过程，取数据就比较简单了，参见以下步骤：

**第一步：获取Key对象的hashCode**

同存储数据一样，获取数据也要先计算hash值。获得key的hashcode，通过Hash散列算法得到hash值，进而定位到数组的位置

**第二步：遍历链表/红黑树**

遍历相同hash的链表，在链表上挨个比较Key对象。调用`equals`方法，将Key对象和链表上所有节点的Key对象进行比较，直到碰到返回true的节点对象为止。

- 先计算hash值定位到存储数据的链表

- 遍历链表，通过`equaks`来确定Key对象，查找到链表上对应的节点

- 返回该节点的`Value`值

**【hashCode和equals方法的关系】**

- equals相同，hashCode一定相同，hash值一定相同；（在同一个链表上）

- hashCode相同，equals不一定相同；（hash冲突）

**总结**

不管是存储数据还是取出数据，都必须先计算hash值，根据哈希值来确定数据在Node[]数组上存放/取出的位置

## 4. 扩容问题

HashMap的位桶数组，初始大小为16。实际使用时，显然大小是可变的。如果位桶数组中的元素达到`0.75 * 数组length`，就重新调整数组大小变为原来的2倍大小。

- 16为初始容量
- 0.75为加载因子

HashMap 总是使用**2的幂**作为哈希表的大小，`tableSizeFor`方法保证了 HashMap 总是使用2的幂作为哈希表的大小：

```java
    /**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

```

扩容很耗时，扩容的本质是定义新的更大的数组，并将原数组内容拷贝到新数组中。

## 5. 节点插入

插入：如果`key`相同，`value`会<u>覆盖</u>为最新

**JDK7**

- 数组 + 链表

- 头插法

【头插法的原因】

1. 头插法相对于尾插法，遍历链表的长度平均来说较短，每次不一定全部遍历
2. 根据时间局部性原理，最近插入的最有可能被使用

**JDK8**

- 数组 + 链表 / 红黑树

- 尾插法