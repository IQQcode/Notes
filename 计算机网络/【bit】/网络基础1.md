[TOC]

# Linux网络编程

软件支持：Xshell  、VMware

## 1.linux （多用户操作系统）基础指令

`ifconfig`查看本机IP地址

Linux终端打开之后，默认处于一个目录下（当前用户的**home**目录）

### 1.1 命令的使用

#### 1.1.1 使用格式：

命令名称  [操作选项]   【操作对象】

#### 1.1.2 目录相关命令

Linux目录结构：树结构  **唯一**：在window下磁盘分区有多少，有多少盘符

**`ls` ** 浏览当前所在**目录**

**`ls -a` ** 浏览所有文件 包括**隐藏文件**（linux中以 `.`开头的文件是隐藏文件，默认不显示）

**`ls -l`**  查看当前文件的详细信息

文件详细信息：

文件类型  文件名称数  操作对象  用户组  文件大小  文件最后一次修改时间

> 1. 以 d开头：目录
> 2. 以 - 开头 txt
> 3. 以 l 开头 连接文件 符号链接文件

**`pwd`**显示当前工作（当前所在）     路径：`/`（根目录下文件信息） `/home`：家文件   `/etc` :  配置文件

​              绝对路径：以根目录为起始的路径

​              相对路径： 以当前路径为起始路径(参考系不同)    .当前路径  .. dev （当前文件上一层文件下dev文件） 

**`mkdir`** 创建一个目录  需要用户指定用户名称    `mkdir text`

**`rmdir`**删除空目录，无法删除非空目录

**`rm`** 删除普通文件     

**`rm  -r  `**递归删除目录下的文件 及目录

**`cp`**拷贝一个普通文件到指定目录下   

**`cp -r`**拷贝目录及目录下所有文件

​           `cp  -r instell/  work/`

**`mv`**将一个文件移动到另一个位置 （剪切）

​         `mv work/install/`

**`cd`** 进入指定目录（改变当前工作路径）

#### 1.1.3 其他命令

**`ctrl c `**中断当前命令

**`cat`**将文件内容打印到终端显示

​          `cat tes`

`t.txt`

**`su`**切换用户

### 1.2 权限

#### 1.2.1 文件权限

文件权限对用户的分类：文件所有者u  文件所属组g     其他用户o

文件权限对操作的分类：可读 r             可写 w          可执行x

对于目录文件的操作权限：可浏览     看创建/删除文件   可进入

**`chmod`**  修改文件权限（前提是文件的所有者  或 管理员（root）才可以修改）

   ` chmod  [augo]【+-】【rwx】`文件名称

   ` chmod u+w file     chmod a+x file  chmod o-w file`

`rwx   r-x   r-x `   三类用户分别对一个问价具备什么操作权限   

### 1.3 常用工具vim最基本的使用

#### 1.3.1 常见操作模式：

普通：进入常见命令操作 （复制 /粘贴/删除） （无法插入数据）

插入：编辑文件内容

底行：文件的保存退出

`vim test.c `

从普通模式切换到插入模式：

​           `i`  从光标所有位置开始插入

从任意模式切换到普通模式：

   `ESC`  一下不行就两下

从普通模式切换到底行模式：:

​           底行模式下的操作： 

​              ：`w`   保存     ： `q`  退出编辑            ：`wq` 保存并退出       ：`q!`强制保存退出

普通模式下的操作：

​              复制：yy(复制光标所在行)    nyy(从光标所在行开始向下复制n行)

​              粘贴：p  向光标所在行下方进行粘贴

​              剪切/删除： `x`     删除光标所在字符

​                                    `dw`  删除光标所在单词

​                                   `dd`   删除光标所在行

​                                    `ndd` 从光标所在行向下删除n行     

救命招数   `u` 撤销上一步操作

# 网络基础

## 1. 网络常见定义

在网络中随着网络的覆盖范围不同，划分出了几种网络：局域网 、城域网 、广域网

因特网：更加国际化的，覆盖范围更大的广域网

互联网：许多路由器之间的星型互联

以太网：组网标准

令牌环网：组网标准

==IP==：复杂的网络中位置标识一个主机   在网络中唯一标识一台**主机**

解决ip地址不够用：

  ==ipv4==： 无符号32位整数  数量不到43亿

  ==ipv6==：128位  16个字节的整数根本解决IP地址不够用）未推广 不兼容ipv4

> 地址包含：源地址  源端口   目的地址  目的端口  协议（通信双方数据解析格式的约定）
> 
> 双绞线：高低电频
> 
> wifi ：电磁波

解决IP地址不够用：（未根本解决）

> DHCP：动态地址分配  自动获取ip地址
> 
> NAT：地址转换技术 

PORT端口：一台主机上唯一标识一个**进程**  无符号16位整数 （0~65535）（ 0-1023被知名协议使用 不建议使用）

端口特性：一个端口只能被一个进程占用  ------   一个进程可以使用多个端口

在网络中的每条数据中都会包含两条信息：源端端口 目的端端口

## 2 . 协议（通信双方数据解析格式的约定）

### 2.1 协议分层

协议分层：协议的封装 在整个通信环境中使用起来更加的方便  按照每一层提供的服务，使用的协议。提供的接口，对复杂的网络环境进行分层。

### 2.2 网络通信环境中的协议分层

**OSI七层参考模型【网络开放互联模型】**： `应用层 >> 表示层 >> 会话层 >> 传输层 >> 网络层 >> 数据链路层 >> 物理层`（对网络划分太细致，不容易实现）

<<<<<<< HEAD
![1568514203740](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1568514203740.png)

![1568514222462](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1568514222462.png)

=======
![text](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1568514150307.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190921134450705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIzMjk1NQ==,size_16,color_FFFFFF,t_70)

**TCP/IP 五层模型** ： `应用层 >> 传输层 >> 网络层  >> 链路层 >> 物理层` 

![1568514258359](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1568514258359.png)

- 应用层：负责应用程序之间的数据沟通  `HTTP,FTP`
- 传输层：负责端与端(端口)之间的数据传输  `TCP,UDP`
- 网络层：负责地址管理与路由选择  `IP` **路由器**
- 链路层：负责相邻之间的数据传输  `以太网协议` **交换机**
- 物理层：负责光电信号的传输  **集线器**

> 程序员：应用层
> 
> 网卡：传输层--->网络层
> 
>  链路层--->物理层

#### I. 应用层

**应用层：负责应用程序之间的数据沟通**

​               知名协议：**HTTP**（超文本传输协议）/ FTP/ DNS/ DHCP   

​                                  网址 - **URL (统一资源定位符) ** ： https://www.baidu.com/ 默认80端口

##### URL编解码

URL:http://user:pass@ip:port(80)/uri？query_string

![1562740888684](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1562740888684.png)

> https://www.baidu.com
> 
> 域名：www.baidu.com ——> IP 115.239.211.112
> 
> 如果没写端口号，默认访问80端口

查询字符串：query_string :以键值对的形式储存在服务器中，每个键值对之间用 `&`

**URL编码/解码 ：**

>    查询寻字符串是用户提交给服务器的数据信息，这些提交的数据中若是==出现特殊字符==，则有可能与url中间隔符产生歧义导致url解析失败：因此查询字符串不能出现特殊字符
> 
>    若是提交的数据中真的有特殊字符需要对查询字符串中的数据进行==url编码操作==；编码之后的数据在对端需要进行==url解码操作==
> 
>    URL编码：将特殊字符每一个字节转换为16进制数字字符串，并且为了表明这两个字符是经过了url编码后的数据，需要在转换后的数据前加上%  
> 
>    例如：`+  -->   %2b` 
> 
>    URL解码：当遇到%，则
> 
>    认为紧跟其后的两个字符需要转码，对紧跟其后的两个字符转换位数字，将第一个字符转为数字左移4位与第二个字符转换后的数据进行相加                              

##### HTTP协议格式

**首行：**

请求首行

​                  请求方法 ：

​                  `GET/POST` ，  `GET`没有正文（更偏向于获取信息）  提交的数据在url的查询字符串中 

​                  协议版本：0.9/1.0/1.1/2

响应首行：

​                  协议版本    响应状态码    状态吗描述信息

![1569030511101](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1569030511101.png)

 响应状态码：                      

1. `1**`表示描述信息

2. `2**`正确处理了客户端请求    <font color=#1E90FF size=4>200</font>
   
    3. `3**`重定向   请求资源已被移位  请其他网址 /  Location指定转移位置 
       
       | 300 | Multiple Choices  | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择                   |
       | --- | ----------------- | --------------------------------------------------------------------- |
       | 301 | Moved Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
       | 302 | Found             | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI                                  |

​          <font color=#FF69B4 size=4>301 永久重定向    302 临时重定向</font>

4. `4**`描述客户端错误/  例如404 ：配置没有找到
   
   | 404 | Not Found | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
   | --- | --------- | ------------------------------------------------------- |
   |     |           |                                                         |

5. `5**`服务器错误 
   
   | 500 | Internal Server Error | 服务器内部错误，无法完成请求                          |
   | --- | --------------------- | --------------------------------------- |
   | 502 | Bad Gateway           | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |

​     更多详见：<https://www.runoob.com/http/http-status-codes.html> 

**客户端请求消息 *Connection***

<img src="C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1569029732078.png" alt="1569029732078" style="zoom:67%;" />

- Content-Length    只要有正文就必须有   正文长度 避免对端应该接受的数据长度

- Transfer -Encoding : `chuncked/` 分块传输，每次发送数据前，先发送当前传送的数据块长度

- Content-Type：正文数据类型   告知浏览器如何处理(展示页面还是下载文件)

- User-Agent :  浏览器版本信息

- 3**/Location ：重定向地址

- Accept—Encoding ：告诉对端 可接受压缩信息

- Accept-language ：告诉对端 可接收的语言格式

- Reference ：告诉对端该 页面是从哪个页面跳过来的

- Set—Cookie ： 将会话ID传递至客户端

- Cookie  ：客户端存储在本地浏览器，而 Session存储在服务器

 **头部：** 以 一个个 `key : val` 组成的键值对，并且各个键值对之间以`\r\n`作为间隔                                

 **空行：**`/n /r`   ---通过`\n \r`识别头部信息间隔头部和结尾 通过头部中的`Content—length`

 **正文：**客户端提交的数据，服务端响应数据

服务器响应消息：

![](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1569033898750.png)

#### II. 传输层

**传输层：负责端与端之间的数据传输**

两个进程之间的数据传输（封装端口信息）

知名协议： TCP /UDP

**端口**（PORT端口：``unit16_t`无符号16位整数）在一个主机上标识一个进程 ，标识接收到的数据应该交给哪个进程处理

> 端口号为 0~65535  ， 0~1023被知名协议使用，不建议使用

![1569034850137](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1569034850137.png)

**一个端口只能被一个进程占用，一个进程可以使用多个端口**  

**五元组：**在网络通信中每一条数据都必须带有一些关键信息（ 源IP/ 源端口 / 目的IP / 目的端口 / 协议） 

- 用于标识网络中的一条通信

  ![1569036692724](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1569036692724.png)

##### UDP协议

UDP协议**：用户数据报协议**

- 特性 ： 无连接，不可靠，面向数据报

> **无连接-不可靠：**通信时不需要建立连接，只需要知道对端地址信息就可以方送数据，并不关心对方是否收到数据，这种方式是不可靠的 ，数据发送后会丢失
> 
> **面向数据报**：向上层交付数据时，只能整条向应用层交付

> 为什么传输数据只能整条向应用层交付？

UDP协议字段：

1） 十六位源目的端口：

2）十六位数据报长度：用于标识整个UDP数据报的长度（包含头部）

> 决定特性：
> 
> - 面向数据报
> - UDP 每次直接传输的报文大小是有长度限制的 ，不能超过64k     

面向数据报特性：

> 16位的数据报长度决定了一个UDP协议的数据data长度**不能大于64k-8**(封装8B的头部长度) ；否则发送失败
> 
> 因此当数据长度大于64k-8b时，就需要用户在应用层进行数据分包，将数据分为一个个小于64-8大小的数据段；
> 
>  UDP 并不保证数据有序到达，需要用户在应用层进行包序管理
> 
> 用户每次调用接口发送数据的时候，udp会直接为这条数据封装udp头部信息，直接发送出去                          
> 
> 为了防止用户接收半条数据，导致udp剩余数据无法根据协议字段中数据报长度确定数据长度，因此udp规定数据只能**整条交付**.
> 
> udp不保证数据有序，因此若是应用层分包还需要用户在应用层进行包序管理
> 
> 应用层在传输层基于udp实现的协议：DNS / DHCP

3）十六位检验和：二进制反码求和  校验接收与发送的数据是否一致

##### TCP 协议

 **TCP 协议：面向连接，可靠传输 ，面向字节流**

TCP三次握手与四次挥手流程以及状态变化

> **为什么握手是三次而挥手是四次？**
> 
> 两次不安全，有可能SYN会延迟，缺乏状态保护的情况下，收到一个SYN就会建立一个新的socket，完整的状态保护避免对一个客户端创建多个socket
> 
> 两次不安全，服务端无法通过客户端的syn确定客户端具有收发数据的能力，需要客户端再次进行确认。

​       

> **挥手为什么是四次？**
> 
> 被动关闭方，收到fin之后对其进行ack回复，但是不能直接关闭socket，因为这时候用户可能正在处理数据（socket接收缓冲区中可能还有堆积的数据），需要用户来确认什么时候关闭socket 发送fin；一次ack和fin不能放在一起。

> **若是三次握手失败，服务端如何处理？**
> 
> 服务端超时等待ack之后，向客户端发送rst报文，然后释放新建的socket资源

> **主动关闭方TIME_WAIT状态的作用？**
> 
> 1，假设没有TIME_WAIT而是直接closed状态，释放socket资源会造成什么危害？
> 
> 在主动关闭方发送的最后一次ACK丢失的情况下：
> 
> 如果主动关闭方使用相同的地址信息立即重启
> 
> 1）.收到f被动关闭方超时等待后重发的fin包，对新连接造成影响
> 
> 2）.发送SYN请求，但是对方等待的是ACK，因为状态不匹配而导致对新连接造成影响
> 
> 2，因此主动关闭方需要等待一段时间:2MSL（报文最大生命周期吗 30s）时间，为了让网络中延迟报文（后续重传的fin请求和ack）都消失在网络中不会对后续连续造成影响。
> 
>  若是对方重发fin请求，可以对其再次进行确认回复。
> 
> 大量TIME_WAIT解决方案：调整msl时间，设置套接字选项（地址复用）

> **可靠传输：**面向连接是可靠传输的前提，但是不保证可靠传输
> 
> 面向连接，
> 
> 保证可靠传输，只能保证数据到达，不保证有序到达
> 
> ​              确认应答机制：对每条数据，向发送方进行确认回复，
> 
> ​              超时重传机制：发送数据后等待一段时间（200ms）若是没有收到确认回复，则认为数据丢失，进行重传
> 
> 协议字段中的包序：序号+确认序号 （保证数据有序的的向应用层交付）
> 
> 协议字段中的校验和：校验接收的数据与发送的数据是否一致，不一致则发送重传请求，否则确认回复

TCP为了保证可靠传输，牺牲了部分性能，（有些性能的损失是没有必要的，比如ack丢失导致的重传） tcp又采用了几种机制来避免无谓的性能损失以及提高性能的方法

**1，滑动窗口机制：**

  **流量控制：**；通过协议字段中的窗口大小（不会大于接收方的接收缓冲区中剩余空间大小）字段控制发送方的数据大小；避免因为发送过快而接收数据处理过慢导致接收缓冲区数据放满后，大量的数据丢失重传降低的性能

窗口大小在每次对数据进行确认回复的时候都会进行重新协商。是、

每一条确认回复中的确认序号，都要保证之前的数据已经完全收到，，没有收到第一条回复，但是收到第二条回复，认为第一和第二条都已经正确传输，避免因为ack丢失而导致的数据重传

**快速重传机制：**接收方收到了第二条数据，但是没有收到第一条，则初步认为第一条数据丢失，则立即发送第一条数据的重传请求，并且连续发送三次

当发送方连续收到三次重传请求的时候，就不需要等待超时，直接对这条数据进行重传，连续三次，是因为要避免因为网络阻塞，数据延迟到达而导致的重 传。

**拥塞控制:**网络通信开始时并不会直接发送窗口大小的数据，而是以一种**慢启动，快增长的**形式进行数据传输，起到一个网络探测在作用，避免开始通信时因为网络状况不好导致的发送数据越多，丢失数据越多的重传性能损失，在快增长的过程中，若出现丢包则初始化拥塞窗口大小，重新开始探测网络状况。

**2.延迟应答机制：**接收方接收数据若是立即回复，则窗口大小会降低，会导致传输速度降低，因此，接收方接收到数据后，并不立即回复，而延迟 一会（不超过500ms）在这期间，用户可能从将数据从缓冲区中取出，可能尽量大的能力保证窗口大小，保证传输速度不会降低；

**3.捎带应答机制：**每一次接收方接收到数据之后对数据进行确认回复，若是单独发送一个数据包（仅仅包含一个tcp报头）是不划算的，解决方案就是将要进行的确认回复和即将要发送的数据合并到一起进行发送，就可以省略一个tcp报头的发送，减少网络中不必要的流量信息。

> tcp的可靠传输：连接管理，确认应答，超时重传，序号/确认序号，校验和
> 
> ​                            滑动窗口机制（流量控制，拥塞控制，快速重传机制），延迟应答，捎带应答 来提高性能

**面向字节流：**数据不会直接发送，而是放到发送缓冲区中，操作系统选择一个合适的时机将合适大小的数据以字节流的形式发送出去，对方接收数据时，可以一次性接收所有数据，也可以一次接收一点，份多次接收

tcp面向字节流特性：传输灵活，但是会造成**粘包问题**

**粘包问题**：TCP传输的数据在发送缓冲区或接收缓冲区中堆积，因为TCP数据收发的灵活性，倒是有可能多条数据当做一条接收；（两条数据的粘连）

TCP粘包的本质原因：TCP在传输层，传输层对数据的格式并不关心，对数据之间没有明显的边界区分，因此会造成数据的粘包。    

解决粘包问题：粘包是TCP在传输层对数据边界不敏感，因此需要用户在应用层进行数据边界管理

​              特殊字符间隔（HTTP），定长数据， 不定长数据在应用协议头中声明数据长度（UDP）。

**4.TCP连接管理中的保活机制**  

​         若是通信双方，长时间（7200s）没有数据往来，则会向对方发送一个保活探测数据包，要求对方对这个保活探测数据包进行回复，若是收到回复：则认为连接正常，若是间隔（75s）发送连续多次（9次）没有收到回复，则认为连接断开。

TCP异常连接断开的情况：断电

> TCP协议字段：
> 
> 16位源/目的端口：负责端与端之间数据传输
> 
> 32位序号/确认序号：保证数据有序交付
> 
> 4位头部长度：解析时获取TCP头部，以4字节为单位（tcp头部最小20字节，最大60字节）
> 
> 6位标志位：URG/ACK/PSH/RST/SYN/FIN
> 
> 16位窗口大小：实现滑动窗口，以及进行流量控制
> 
> 16位校验和：保证数据一致性
> 
> 16位紧急指针：带外数据
> 
> 40字节的选项数据：可有可无。

#### III. 网络层

**网络层：负责地址管理与路由选择；**

**IP:路由器：路由选择**

知名协议：IP协议  设备：路由器：实现数据的路由转发；

**路由选择：**在复杂的网络环境中，为每一条数据选择一条合适的传输路径，最佳的路径依托于良好的地址管理

网络中的IP地址不能随意分配，因为随意分配很容易造成IP地址冲突；因此IP地址需要得到合理的管理

一个路由器可以组件一个局域网，这时路由器向局域网中的主机分配IP地址的时候，就必须带有自己网络的标识---**网络号。**这时候只需要将每个网络的网络号规范起来就可以避免IP地址冲突

在一个局域网中，路由器向主机分配IP地址，还要能够在局域网中标识这个主机，这个标识叫**主机号**

IP的组成网络号+主机号

保证相邻的网络不能具有相同的网络号就可以尽可能的避免IP冲突

网址的划分：

早期划分方式：A/B/C/D/E

A类地址：低24位是主机号  A类网络地址主机号有2^24    地址范围0.0.0.0~127.255.255.255

B类地址：低16位是主机号，B类网络地址主机号有65536个  地址范围128.0.0.0~191.255.255.255

C类地址：低8位是主机号，C类网络地址主机号有256个  地址范围192.0.0.0~223.255.255.255

D类地址

现在解决方案-CIDR：加入了一个字段叫子网掩码。通过子网掩码来对网络进行划分

子网掩码：由一串连续的二进制1组成的一个无符号4个字节的整数

192.168.122.132  255.255.255.0

作用：

​       **子网掩码与IP地址相与能够得到网络号** 192.168.122.132 & 255.255.255.0 =192.168.122.0

​      **子网掩码取反（得到最大主机号）** ，**可以得到网络中主机号的个数**  ~255.255.255.0 = 255+1 =256

现在有一个C类网络地址，将这个C类网络划分出20个子网，请问每个子网的子网掩码是多少，IP地址范围是多少，以及各个网络的网络号是多少

C类网络地址有256个主机号，平均划分20个子网，每个子网中主机号个数256/20

每个子网中主机号个数是12，子 网掩码是连续的1，因此12取反无法得到连续1 ，在每个子网主机号能少 ； ~0.0.0.7 = 255 .255.255.248

~00001011  = 11110100

~00000111 = 11111000

在一个完网络中，并不是所有的主机号都能分配给主机

主机号全为0的IP地址：网络号 ，用于标识一个网络

主机号全为1的IP地址--udp广播地址   

127.0.0.0  本机虚拟回环网卡地址  用于本机的网络测试

在RFC1918中进行规定，用于组件私网的网段也不能随意使用。只有以下几个网段可以用于组件私网：

![1563095170079](E:\javaclass\不能用作组件私网.png)

相邻的网路不能使用相同的网络号

路由选择：

路由表：每个路由器上都有一个路由表，记录的连接在路由器上的网络

ip协议字段 

​         4位协议版本：IPV4/IPv6

​         4位头部长度：IP报文头最大长度69个字节（以4字节为单位）

​          8位服务类型：4位TOS字段（最小延时/最大吞吐量/最高可靠习性/最小成本） 1位保留位

​          16位报文长度：限制一个IP报文最大长度64K udp 数据最大长度  64k—20-8

MTU ：最大传输单元

 当mtu<udp 数据长度<64k-=20-8 ,链路层则不支持大于mtu大小数据传输，这时候网络先获取下层mtu大小，在网络层对数据进行分析。

16位标识：udp数据可能在网络层进行数据分片，这个标识则可以指定当前分片属于哪个udp数据包

13位片偏移量

#### IV. 链路层

**链路层：负责相邻设备之间的数据传输（MAC地址，用于定义相邻设备）**

协议：Ether；设备： 交换机（实现相邻设备数据之间的固定转发）

协议：Ether

#### V. 物理层

**物理层：负责光电信号的传输；**

以太网协议：使用的物理介质规定；

设备 ---->  集线器HUB：数据集中转发，信号放大

## 3. 网络通信中数据的传输流程

数据封装-->数据分用-->