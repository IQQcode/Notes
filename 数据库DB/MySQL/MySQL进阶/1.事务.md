## ❌事务简介

> 事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

**事务是SQL语句组成的逻辑处理单元，要么都执行，要么都不执行。**

**MySQL事务是默认提交的**。

开启事务`start transsction;`

- 开启之后，增删改需要`commit`提交才能执行成功（默认的隔离级别为**可重复读**）
- 如果发生异常需要`roll back`回滚

<br>

## 事务ACID属性

![事物的特性](1.事务.assets/事务特性.png)

1. **原子性（Atomicity）：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性（Consistency）：** 执行事务前后，会使数据从一个状态切换到另一个状态，数据保持一致
3. **隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

Mysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式：

```sql
show variables like 'tx_isolation';
```

![1554331600009](1.事务.assets/1554331600009.png)

<br>

## 并发事务带来的问题

**同时运行的多个事务** 访问 **数据库中相同的数据时**，如果没有采取隔离级别，会导致并发问题

- **脏读（Dirty read）:** 事务（T1）正在访问数据并且对数据进行了修改，而这种修改还没有提交`commit`到数据库中，这时另外一个事务（T2）也访问了这个数据，然后使用了这个数据。<u>因为这个数据是还没有提交的数据</u>，那么另外一个事务读到的这个数据是<mark>临时的“脏数据”</mark>，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**并发事务处理带来的问题**

| 问题                               | 含义                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 丢失更新（Lost Update）            | 当两个或多个事务选择同一行，后面事务的修改值 覆盖了 前面的事务的修改值 |
| 脏读（Dirty Reads）                | 一个事务访问到了另一个事务 还未`commit`提交的数据            |
| 不可重复读（Non-Repeatable Reads） | 在同一个事务中执行了两次查询语句，两次查询出的结果不相同     |
| 幻读（Phantom Reads）              | 一个事务按照 <u>相同的查询条件</u> 重新读取以前查询过的数据，却发现其他事务插入了 满足其查询条件的新数据，再次查询多出了之前 不存在的数据 |


**脏读和不可重复读区别：**

- 脏读：只读取了一次
- 不可重复读：修改之前和修改之后读取了两次

**不可重复读和幻读区别：**

- 不可重复读：针对的是数据被修改（数据的数目不变）
- 幻读：针对的是插入删除（数据的数目发生了变化）

## 隔离级别

**数据库事务的隔离性**：数据库系统必须具有隔离 并发运行 各个事务的能力，使它们不会相互影响，避免各种并发问题。

**隔离级别：**一个事务与其他事务的 <u>隔离程度</u> 称为隔离级别 

隔离界别并不是越高越好，隔离级别越高性能越差。

<hr>

**SQL 标准定义了四个隔离级别：**

- **READ-UNCOMMITTED(读未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

------

>✔为可以解决，❌为无法解决


| 隔离级别         |  丢失更新 | 脏读 | 不可重复读 | 幻读 |
| ---------------- |   :--: |:--: | :--------: | :--: |
| READ-UNCOMMITTED | ✔  |  ❌  |     ❌     |  ❌  |
| READ-COMMITTED   | ✔  |   ✔  |     ❌     |  ❌  |
| REPEATABLE-READ  |  ✔  | ✔   |     ✔     |  ❌   |
| SERIALIZABLE     |  ✔  | ✔  |     ✔     |  ✔  |

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。

我们可以通过`SELECT @@tx_isolation;`命令来查看

```sql
mysql> SELECT @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
```