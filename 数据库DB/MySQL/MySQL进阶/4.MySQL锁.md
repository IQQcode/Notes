## 1. Mysql锁概述

**锁概述**锁是计算机协调多个进程或线程并发访问某一资源的机制（避免资源争抢）。

### 2. 锁分类

**从对数据操作的粒度分 ： **

- 表锁：操作时，会锁定整个表

- 行锁：操作时，会锁定当前操作行

**从对数据操作的类型分：**

- 读锁（共享锁）：多个事务对于同一数据可以共享同一把锁，多个读操作可以同时进行而不会互相影响

- 写锁（排它锁）：不能与其他锁并存。当前操作没有完成之前，它会阻断其他写锁和读锁

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：

| 存储引擎 | 表级锁 | 行级锁 | 页面锁 |
| -------- | ------ | ------ | ------ |
| MyISAM   | 支持   | 不支持 | 不支持 |
| InnoDB   | 支持   | 支持   | 不支持 |

MySQL这3种锁的特性可大致归纳如下 ：

![image-20200824163558057](4.MySQL锁.assets/image-20200824163558057.png)

从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。



## 2. MyISAM 表锁

MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。

### 如何加表锁

**加锁的过程是自动的**。MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。

显示加表锁语法：

```SQL
加读锁 ： lock table table_name read;

加写锁 ： lock table table_name write；
```

锁模式的相互兼容性如表中所示：

![1553905621992](4.MySQL锁.assets/1553905621992.png)

由上表可见： 

- 简而言之，就是读锁会阻塞写，但是不会阻塞读。

- 而写锁，则既会阻塞读，又会阻塞写。

此外，MyISAM 的读写锁调度是**写优先**，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，*其他线程不能做任何操作*，大量的更新会使查询很难得到锁，从而造成永远阻塞。

<br>

## 3. InnoDB 行锁

###  行锁介绍

**行锁特点 ：**

- 偏向InnoDB 存储引擎，开销大，加锁慢；
- 会出现死锁；
- 锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

InnoDB 与 MyISAM 的最大不同有两点：**一是支持事务；二是采用了行锁**

<br>

### InnoDB 的行锁模式

**InnoDB 支持行锁和表锁**

- 对于`UPDATE`、`DELETE`和`INSERT`语句，InnoDB会自动给涉及数据集加排他锁（X)；

- 对于普通`SELECT`语句，InnoDB不会加任何锁；

可以通过以下语句显示给记录集加共享锁或排他锁 

```
共享锁(S): SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE

排他锁(X): SELECT * FROM table_name WHERE ... FOR UPDATE
```



### 索引行锁升级为表锁

**如果不通过索引条件检索数据**，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。

**索引失效，最终行锁变为表锁 **

为何索引会失效？——— 使用的索引字段的数据类型 与 定义的数据类型不符。

查看当前表的索引 ： 

```sql
show  index  from test_innodb_lock ;
```

![1554385956215](4.MySQL锁.assets/1554385956215.png) 

由于执行更新时 ， name字段本来为`varchar`类型， 我们是作为`int`类型使用，存在类型转换的异常，所以索引失效，行锁变为表锁



### 总结

InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。**当系统并发量较高的时候**，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。

但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。

**优化建议：**

- 避免无索引行锁升级为表锁，尽可能让所有数据检索都能通过索引来完成
- 合理设计索引，尽量缩小锁的范围
- 尽可能减少索引条件，及索引范围，避免间隙锁
- 尽量控制事务大小，减少锁定资源量和时间长度

